---
layout:     post
title:      HarmonyOS内存模块分析
subtitle:   内存分配函数分析
date:       2020-10-12
author:     Weizhou
header-img: img/p3_bg.jpg
catalog: true
tags:
    - Operating System
---

## 前言
当前HarmonyOS开源的源码适用于小型IOT设备，从开源仓代码分析，内核使用的是LiteOS，但与现有的
开源LiteOS有着较大的不同。其中与开源版本LiteOS最大的不同之处当数内存管理模块。HarmonyOS支持Arm Cortex-A7
并且可以通过使能MMU对虚拟内存进行管理。该系列文章将对HarmonyOS内存模块进行详细的代码剖析讲解，
该篇文章的分析内容主要侧重与内存模块中分配过程所涉及的函数，后续将会对内存初始化，ELF加载等过程进行
详细的解读。

## 正文
该文分析的内容类比与Linux，从kmalloc和vmalloc入手，分析内核中内存分析的流程。
Linux中kmalloc可类比于HarmonyOS中的LOS_KernelMalloc，vmalloc可类比于HarmonyOS中的LOS_VMalloc函数。
本文将从两个函数入手，分析页面的分配管理方法以及涉及到的相关结构体。

### LOS_KernelMalloc
*函数原型：* `VOID *LOS_KernelMalloc(UINT32 size)`<br>
&emsp;&emsp;LOS_KernelMalloc可类比于Linux内核的kmalloc申请连续的物理地址内存空间，但对比kmalloc的接受传参，LOS_KernelMalloc函数缺少了flags入参，该入参在Linux中表示分配出的页内存空间的不同用途。如GFP_KERNEL表示分配出的内核内存页，用于内核进程；GFP_USER表示分配出的页内存将用于用户态进程。下文将从LOS_KernelMalloc入手进行逐层分析HMOS的内存分配策略和实现方式。<br>
&emsp;&emsp;内核主要使用LOS_KernelMalloc接口申请内核态内存空间。LOS_KernelMalloc的分配策略大体与Linux的策略相似：分配大块内存时（超过4K）调用LOS_PhysPagesAllocContiguous函数以页为单位分配出一个连续的内存空间；否则调用LOS_MemAlloc函数（与开源LiteOS函数接口相同），该函数的内存分配策略为bestfit，从内存池中找到合适的大小进行分配。<br><br>
*函数源码：*<br>
```cpp
VOID *LOS_KernelMalloc(UINT32 size)
{
    VOID *ptr = NULL;

    if (OsMemLargeAlloc(size)) {
        ptr = LOS_PhysPagesAllocContiguous(ROUNDUP(size, PAGE_SIZE) >> PAGE_SHIFT);
    } else {
        ptr = LOS_MemAlloc(OS_SYS_MEM_ADDR, size);
    }

    return ptr;
}
```
接下来主要分析页面分配的流程，LOS_KernelMalloc获取page的关键调用路径：<br>
`LOS_KernelMalloc`->`LOS_PhysPagesAllocContiguous`-> `OsVmPhysPagesGet`->`OsVmPhysPagesAlloc`接下来将对涉及的函数进行逐个分析。<br><br>
**VOID *LOS_PhysPagesAllocContiguous(size_t nPages)**<br>
```cpp
VOID *LOS_PhysPagesAllocContiguous(size_t nPages)
{
    LosVmPage *page = NULL;

    if (nPages == 0) {
        return NULL;
    }

    page = OsVmPhysPagesGet(nPages);
    if (page == NULL) {
        return NULL;
    }

    return OsVmPageToVaddr(page);
}
```
&emsp;&emsp;该函数主要干了两件事情，首先调用OsVmPhysPagesGet函数获取指定数量的页内存，再通过调用OsVmPageToVaddr函数将页内存转换成虚拟地址。<br><br>
**STATIC LosVmPage *OsVmPhysPagesGet(size_t nPages)**
```cpp
STATIC LosVmPage *OsVmPhysPagesGet(size_t nPages)
{
    UINT32 intSave;
    struct VmPhysSeg *seg = NULL;
    LosVmPage *page = NULL;
    UINT32 segID;

    if (nPages == 0) {
        return NULL;
    }

    for (segID = 0; segID < g_vmPhysSegNum; segID++) {
        seg = &g_vmPhysSeg[segID];
        LOS_SpinLockSave(&seg->freeListLock, &intSave);
        page = OsVmPhysPagesAlloc(seg, nPages);
        if (page != NULL) {
            /* the first page of continuous physical addresses holds refCounts */
            LOS_AtomicSet(&page->refCounts, 0);
            page->nPages = nPages;
            LOS_SpinUnlockRestore(&seg->freeListLock, intSave);
            return page;
        }
        LOS_SpinUnlockRestore(&seg->freeListLock, intSave);
    }
    return NULL;
}
```
&emsp;&emsp;在HMOS的内存管理机制中引入了VmPhysSeg结构体，该结构体可以理解为是Linux中简易的Zone，VmPhysSeg的结构体如所示：<br>
```cpp
typedef struct VmPhysSeg {
    PADDR_T start;            /* The start of physical memory area */
    size_t size;              /* The size of physical memory area */
    LosVmPage *pageBase;      /* The first page address of this area */

    SPIN_LOCK_S freeListLock; /* The buddy list spinlock */
    struct VmFreeList freeList[VM_LIST_ORDER_MAX];  /* The free pages in the buddy list */

    SPIN_LOCK_S lruLock;
    size_t lruSize[VM_NR_LRU_LISTS];
    LOS_DL_LIST lruList[VM_NR_LRU_LISTS];
} LosVmPhysSeg;
```
&emsp;&emsp;Linux中zone的作用主要是区分DMA内存区和普通内存区，HMOS中的Seg结构体有相似的功能，但结构体中成员变量数量相对于Linux的Zone结构体减少了很多。这里不做具体的区别分析，只做HMOS内存管理的分析。HMOS的seg结构体更类似于段页式内存管理中对段的描述。支持将系统所有可用的内存地址空间分割成多个段，再将段分为不同数量的页挂载到freeList列表中。<br>
&emsp;&emsp;start成员变量表示该seg结构体管理的物理内存起始地址；size表示该区域的大小；pageBase指向该块内存区域起始的页内存结构体；freeList是结构体数组，使用伙伴算法管理内存页。VM_LIST_ORDER_MAX最大值为9，基于伙伴内存的算法可判断出freeList[0]中应该存放的是2^0数量大小的连续也空间，最大2^8表示支持最大256个连续页空间的内存，即管理256*4k大小的空间。<br>
&emsp;&emsp;从页分配算法来说，OsVmPhysPagesGet函数遍历了所有的seg，然后调用OsVmPhysPagesAlloc函数从能够满足分配npage数量大小的连续页内存的seg结构体中获取到page结构体指针。<br><br>
**LosVmPage OsVmPhysPagesAlloc(struct VmPhysSeg seg, size_t nPages)**
```cpp
LosVmPage *OsVmPhysPagesAlloc(struct VmPhysSeg *seg, size_t nPages)
{
    struct VmFreeList *list = NULL;
    LosVmPage *page = NULL;
    UINT32 order;
    UINT32 newOrder;

    if ((seg == NULL) || (nPages == 0)) {
        return NULL;
    }

    order = OsVmPagesToOrder(nPages);
    if (order < VM_LIST_ORDER_MAX) {
        for (newOrder = order; newOrder < VM_LIST_ORDER_MAX; newOrder++) {
            list = &seg->freeList[newOrder];
            if (LOS_ListEmpty(&list->node)) {
                continue;
            }
            page = LOS_DL_LIST_ENTRY(LOS_DL_LIST_FIRST(&list->node), LosVmPage, node);
            goto DONE;
        }
    }
    return NULL;
DONE:
    OsVmPhysFreeListDelUnsafe(page);
    OsVmPhysPagesSpiltUnsafe(page, order, newOrder);
    return page;
}
```
&emsp;&emsp;首先通过OsVmPagesToOrder函数计算出nPages对应所需最小的order值，然后以order值为初始值向上便利当前seg结构体中freeList[order]上是否有空闲的连续order大小的连续page内存空间。最后通过OsVmPhysFreeListDelUnsafe函数将该page从该seg的freeList[order]数组中删除；再通过OsVmPagesSplitUnsafe函数将当前order的连续page内存页做适当的split操作，并将未使用的page挂在到对应order大小的freeList[order]数组上，这样就完成了一次page的分配过程。
